'use strict';

/**
 * BUNZ Framework - Bundled Critical Path
 * Auto-generated by tools/bundle.ts
 * Contains: loader.js + lifecycle.js + scripts.js + core.js + routing.js
 * DO NOT EDIT - Run `bun run bundle` to regenerate
 */

// ============================================================================
// LOADER (4.5 KB)
// Source: src/client/js/core/loader.js
// ============================================================================

/**
 * BUNZ Loader - Lazy load modules on demand
 * Only loads modules when actually needed
 */
class BunzLoader {
    loaded = new Set();
    loading = new Map();
    
    // Module path mappings
    modulePaths = {
        // Core modules (lazy-loaded when needed)
        'scripts': '/js/core/scripts.js',
        'state': '/js/core/state.js',
        'cache': '/js/core/cache.js',
        
        // UI modules (lazy-loaded when needed)
        'modal': '/js/ui/modal.js',
        'toast': '/js/ui/toast.js',
        'cookies': '/js/ui/cookies.js',
        'a11y': '/js/ui/a11y.js',
        
        // Utility modules (lazy-loaded when needed)
        'errors': '/js/utils/errors.js',
        'forms': '/js/utils/forms.js',
        
        // Feature modules (lazy-loaded when needed)
        'templates': '/js/modules/templates.js',
        'components': '/js/modules/components.js',
        'i18n': '/js/modules/i18n.js',
        'webrtc': '/js/modules/webrtc.js',
        'map': '/js/modules/map.js',
        'canvas': '/js/modules/canvas.js',
        'realtime': '/js/modules/realtime.js',
    };
    
    /**
     * Load a module lazily
     */
    async load(moduleName) {
        // Already loaded
        if (this.loaded.has(moduleName)) {
            return Promise.resolve();
        }
        
        // Currently loading
        if (this.loading.has(moduleName)) {
            return this.loading.get(moduleName);
        }
        
        // Start loading
        const promise = this.loadScript(moduleName);
        this.loading.set(moduleName, promise);
        
        try {
            await promise;
            this.loaded.add(moduleName);
            this.loading.delete(moduleName);
            console.log(`‚úÖ Lazy-loaded: ${moduleName}`);
        } catch (error) {
            console.error(`‚ùå Failed to load: ${moduleName}`, error);
            this.loading.delete(moduleName);
            throw error;
        }
        
        return promise;
    }
    
    /**
     * Load script element
     */
    loadScript(moduleName) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            // Use module path mapping, fallback to modules/ directory
            script.src = this.modulePaths[moduleName] || `/js/modules/${moduleName}.js`;
            script.defer = true;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if module is loaded
     */
    isLoaded(moduleName) {
        return this.loaded.has(moduleName);
    }
    
    /**
     * Load multiple modules
     */
    async loadAll(moduleNames) {
        return Promise.all(moduleNames.map(name => this.load(name)));
    }
}

window.bunzLoader = new BunzLoader();
console.log('‚úÖ BUNZ Loader initialized (lazy-loading enabled)');

// ============================================================================
// AUTO-LOAD MODULES ON DEMAND
// ============================================================================

// ============================================================================
// SMART AUTO-LOADING
// Load modules automatically when needed (after critical path)
// ============================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Delay non-critical loads slightly (after critical path renders)
    requestIdleCallback(() => {
        // Scripts.js - BUNDLED, don't load again!
        // bunzLoader.load('scripts');
        
        // Modal.js - if modal container exists
        if (document.getElementById('bunz-modal')) {
            bunzLoader.load('modal');
        }
        
        // Toast.js - useful for notifications
        bunzLoader.load('toast');
        
        // Cookies.js - only if no consent given
        if (!localStorage.getItem('cookie-consent')) {
            bunzLoader.load('cookies');
        }
        
        // A11y.js - accessibility features
        bunzLoader.load('a11y');
        
        // Forms.js - only if forms exist
        if (document.querySelector('form')) {
            bunzLoader.load('forms');
        }
    }, { timeout: 1000 });
});

// Auto-load templates.js when needed (room/meeting pages)
document.addEventListener('bunz:loaded', () => {
    const needsTemplates = document.querySelector('.video-container, .room-page-container, .meeting-page');
    if (needsTemplates && !window.bunzTemplates) {
        bunzLoader.load('templates');
    }
});



// ============================================================================
// LIFECYCLE (2.6 KB)
// Source: src/client/js/core/lifecycle.js
// ============================================================================

/**
 * @fileoverview BUNZ Lifecycle - Component lifecycle management
 * @description Provides hooks for before/after swap and cleanup
 * @version 1.0.0
 * @license MIT
 */

/**
 * BUNZ Lifecycle class for managing component lifecycles
 * @class
 */
class BunzLifecycle {
    /** @type {Map<string, Function[]>} Cleanup listeners map */
    listeners = new Map();
    
    /**
     * Trigger before content swap with cancellable event
     * @param {string} target - Target selector
     * @param {string} url - URL being loaded
     * @returns {Promise<boolean>} True if swap should proceed
     */
    async beforeSwap(target, url) {
        const event = new CustomEvent('bunz:beforeSwap', {
            detail: { target, url },
            cancelable: true
        });
        document.dispatchEvent(event);
        
        // Call registered cleanup functions
        if (this.listeners.has(target)) {
            for (const cleanup of this.listeners.get(target)) {
                await cleanup();
            }
            this.listeners.delete(target);
        }
        
        return !event.defaultPrevented;
    }
    
    /**
     * Trigger after content swap event
     * @param {string} target - Target selector
     * @param {string} url - URL that was loaded
     * @param {string} html - HTML content that was swapped
     * @returns {void}
     */
    afterSwap(target, url, html) {
        document.dispatchEvent(new CustomEvent('bunz:afterSwap', {
            detail: { target, url, html }
        }));
    }
    
    /**
     * Register cleanup function for target element
     * @param {string|HTMLElement} target - Target selector or element
     * @param {Function} fn - Cleanup function to execute
     * @returns {void}
     */
    onCleanup(target, fn) {
        const selector = typeof target === 'string' ? target : '#app';
        if (!this.listeners.has(selector)) {
            this.listeners.set(selector, []);
        }
        this.listeners.get(selector).push(fn);
    }
    
    /**
     * Manually trigger cleanup for target
     * @param {string} target - Target selector (default: '#app')
     * @returns {Promise<void>}
     */
    async cleanup(target = '#app') {
        if (this.listeners.has(target)) {
            for (const cleanup of this.listeners.get(target)) {
                await cleanup();
            }
            this.listeners.delete(target);
        }
        
        document.dispatchEvent(new CustomEvent('bunz:cleanup', {
            detail: { target }
        }));
    }
}

/** @type {BunzLifecycle} Global BunzLifecycle instance */
window.bunzLifecycle = new BunzLifecycle();

console.log('‚úÖ BUNZ Lifecycle initialized');


// ============================================================================
// SCRIPTS (3.1 KB)
// Source: src/client/js/core/scripts.js
// ============================================================================

/**
 * @fileoverview BUNZ Scripts - Reliable script execution in swapped content
 * @description Executes inline and external scripts from loaded HTML
 * @version 1.0.0
 * @license MIT
 */

/**
 * BUNZ Scripts class for managing script execution
 * @class
 */
class BunzScripts {
    /** @type {Set<string>} Loaded scripts cache */
    loadedScripts = new Set();
    
    /**
     * Execute all scripts in HTML string or element
     * @param {string} html - HTML string containing scripts
     * @param {string|HTMLElement} container - Container element
     * @returns {Promise<void>}
     */
    async execute(html, container) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        const scripts = tempDiv.querySelectorAll('script');
        const el = typeof container === 'string' ? document.querySelector(container) : container;
        
        for (const oldScript of scripts) {
            await this.executeScript(oldScript, el);
        }
        
        // Auto-load component script if exists
        this.autoLoadComponentScript(html);
    }
    
    /**
     * Execute a single script element
     * @param {HTMLScriptElement} oldScript - Original script element
     * @param {HTMLElement} container - Container element
     * @returns {Promise<void>}
     */
    async executeScript(oldScript, container) {
        const newScript = document.createElement('script');
        
        // Copy attributes
        Array.from(oldScript.attributes).forEach(attr => {
            newScript.setAttribute(attr.name, attr.value);
        });
        
        // Handle external vs inline
        if (oldScript.src) {
            // External script
            if (this.loadedScripts.has(oldScript.src)) {
                return; // Already loaded
            }
            
            return new Promise((resolve, reject) => {
                newScript.onload = () => {
                    this.loadedScripts.add(oldScript.src);
                    resolve();
                };
                newScript.onerror = reject;
                document.head.appendChild(newScript);
            });
        } else {
            // Inline script - wrap in IIFE to avoid variable conflicts
            newScript.textContent = `(function() {\n${oldScript.textContent}\n})();`;
            container.appendChild(newScript);
        }
    }
    
    /**
     * Auto-load component-specific script based on route
     * DEPRECATED: Page scripts are now embedded in HTX files
     * Keeping method for backwards compatibility, but it does nothing
     * @param {string} html - HTML content (unused)
     * @returns {void}
     */
    autoLoadComponentScript(html) {
        // Page scripts are now self-contained in HTX files
        // This method is kept for backwards compatibility but does nothing
        return;
    }
    
    /**
     * Clear loaded scripts cache
     * @returns {void}
     */
    clearCache() {
        this.loadedScripts.clear();
    }
}

/** @type {BunzScripts} Global BunzScripts instance */
window.bunzScripts = new BunzScripts();

console.log('‚úÖ BUNZ Scripts initialized');


// ============================================================================
// CORE (2.1 KB)
// Source: src/client/js/core/core.js
// ============================================================================

/**
 * @fileoverview BUNZ Core - Minimal Component Loader
 * @version 1.0.0
 * @license MIT
 */

/**
 * BUNZ Core class for loading and caching HTML components
 * @class
 */
class BunzCore {
    /** @type {Map<string, string>} Component cache */
    cache = new Map();
    
    /**
     * Load HTML component into target element
     * @param {string} path - Path to HTX component
     * @param {string|HTMLElement} target - Target element selector or element
     * @returns {Promise<void>}
     */
    async load(path, target) {
        const el = typeof target === 'string' ? document.querySelector(target) : target;
        if (!el) return console.error('Target not found:', target);
        
        try {
            const html = await this.fetch(path);
            el.innerHTML = html;
            
            // Execute scripts in the loaded HTML
            if (window.bunzScripts) {
                await window.bunzScripts.execute(html, el);
            }
            
            document.dispatchEvent(new CustomEvent('bunz:loaded', { detail: { component: path } }));
        } catch (e) {
            console.error('Load error:', e);
        }
    }
    
    /**
     * Fetch component HTML with caching
     * @param {string} path - Path to HTX component
     * @returns {Promise<string>} HTML content
     * @throws {Error} If HTTP request fails
     */
    async fetch(path) {
        const url = path.startsWith('/htx/') ? path : `/htx/${path}`;
        if (this.cache.has(url)) return this.cache.get(url);
        
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        const html = await res.text();
        this.cache.set(url, html);
        return html;
    }
}

/** @type {BunzCore} Global BunzCore instance */
window.bunzCore = new BunzCore();

/**
 * Global helper function to load components
 * @param {string} c - Component path
 * @param {string|HTMLElement} t - Target
 * @returns {Promise<void>}
 */
window.loadComponent = (c, t) => bunzCore.load(c, t);

console.log('‚úÖ BUNZ Core initialized');


// ============================================================================
// ROUTING (11.6 KB)
// Source: src/client/js/core/routing.js
// ============================================================================

/**
 * BUNZ - Minimal Routing & Navigation
 * Full-featured: lifecycle, errors, state, cache, forms, a11y, realtime
 * 
 * Usage:
 *   <a href="/htx/pages/dashboard.htx#app" bz-guard="auth">Dashboard</a>
 *   <form bz-post="/api/login" bz-target="#app">...</form>
 *   <div bz-preserve="search-form">...</div>
 */

(function() {
    'use strict';
    
    // Configuration
    const config = {
        authEndpoint: '/api/me',
        loginModal: '/htx/pages/login.htx',
        defaultTarget: '#app'
    };
    
    // Auth guards
    const guards = {
        auth: async () => {
            const res = await fetch(config.authEndpoint, { credentials: 'include' });
            if (!res.ok && window.openModal) {
                await window.openModal(config.loginModal);
                return false;
            }
            return res.ok;
        },
        guest: async () => {
            const res = await fetch(config.authEndpoint, { credentials: 'include' });
            if (res.ok) {
                await load('/htx/pages/dashboard.htx', '#app');
                return false;
            }
            return true;
        }
    };
    
    // Load content with full feature integration
    async function load(url, target, pushState = true) {
        try {
            const targetEl = document.querySelector(target || config.defaultTarget);
            if (!targetEl) return;
            
            // Check if already on this page
            if (pushState && url.includes('.htx')) {
                let route = url.replace('/htx/pages/', '/').replace('.htx', '');
                if (route === '/index') route = '/';
                if (window.location.pathname === route) {
                    console.log('Already on this page, skipping reload');
                    return;
                }
            }
            
            // Check if content is pre-rendered (SSR)
            const isPrerendered = targetEl.getAttribute('data-prerendered') === 'true';
            if (isPrerendered && !pushState) {
                console.log('‚úÖ Using pre-rendered SSR content');
                targetEl.removeAttribute('data-prerendered');
                
                // Still execute scripts in pre-rendered content
                if (window.bunzScripts) {
                    const html = targetEl.innerHTML;
                    await window.bunzScripts.execute(html, targetEl);
                }
                
                // Accessibility - manage focus for pre-rendered content
                if (window.bunzA11y) {
                    window.bunzA11y.manageFocus(targetEl);
                    window.bunzA11y.announce('Page loaded');
                }
                
                // Update URL (no animation for initial/prerendered load)
                if (url.includes('.htx')) {
                    let route = url.replace('/htx/pages/', '/').replace('.htx', '');
                    if (route === '/index') route = '/';
                    window.history.replaceState({ url, target }, '', route);
                }
                
                // Lifecycle: afterSwap
                if (window.bunzLifecycle) {
                    window.bunzLifecycle.afterSwap(target, url, targetEl.innerHTML);
                }
                
                // Dispatch event
                document.dispatchEvent(new CustomEvent('bz:loaded', { 
                    detail: { url, target, prerendered: true } 
                }));
                
                return;
            }
            
            // Lifecycle: beforeSwap + cleanup
            if (window.bunzLifecycle) {
                const proceed = await window.bunzLifecycle.beforeSwap(target, url);
                if (!proceed) return;
            }
            
            // Preserve state
            if (window.bunzState) {
                window.bunzState.preserveElements(targetEl);
            }
            
            // Fade out (only for client-side navigation)
            targetEl.classList.add('fade-out');
            await new Promise(r => setTimeout(r, 100));
            
            // Use bunzCore.fetch for fetching HTML with caching
            let html;
            try {
                if (window.bunzCore) {
                    html = await window.bunzCore.fetch(url);
                } else {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    html = await res.text();
                }
            } catch (error) {
                // Error boundary
                if (window.bunzErrors) {
                    return window.bunzErrors.handle(error, url, targetEl, { pushState });
                }
                throw error;
            }
            
            // Swap content
            targetEl.innerHTML = html;
            
            // Restore preserved state
            if (window.bunzState) {
                window.bunzState.restoreElements(targetEl);
            }
            
            // Execute scripts
            if (window.bunzScripts) {
                await window.bunzScripts.execute(html, targetEl);
            }
            
            // Fade in (trigger animation) - only for client-side navigation
            targetEl.classList.remove('fade-out');
            targetEl.classList.add('fade-in');
            // Remove fade-in class after animation completes
            setTimeout(() => targetEl.classList.remove('fade-in'), 100);
            
            // Accessibility
            if (window.bunzA11y) {
                window.bunzA11y.manageFocus(targetEl);
                window.bunzA11y.announce('Page loaded');
            }
            
            // Update URL
            if (pushState && url.includes('.htx')) {
                let route = url.replace('/htx/pages/', '/').replace('.htx', '');
                if (route === '/index') route = '/';
                window.history.pushState({ url, target }, '', route);
            }
            
            // Lifecycle: afterSwap
            if (window.bunzLifecycle) {
                window.bunzLifecycle.afterSwap(target, url, html);
            }
            
            // Dispatch event
            document.dispatchEvent(new CustomEvent('bz:loaded', { 
                detail: { url, target } 
            }));
            
        } catch (err) {
            console.error('BUNZ Load Error:', err);
            if (window.bunzErrors) {
                window.bunzErrors.handle(err, url, target, { pushState });
            }
        }
    }
    
    // Handle bz-get clicks
    document.addEventListener('click', async (e) => {
        const el = e.target.closest('[bz-get], a[href*=".htx"]');
        if (!el) return;
        
        e.preventDefault();
        
        // Extract URL and target
        let url, target;
        if (el.hasAttribute('bz-get')) {
            url = el.getAttribute('bz-get');
            target = el.getAttribute('bz-target');
        } else {
            const href = el.getAttribute('href');
            const [path, hash] = href.split('#');
            url = path;
            target = hash ? `#${hash}` : null;
        }
        
        const guard = el.getAttribute('bz-guard');
        
        // Check guard
        if (guard && guards[guard]) {
            const passed = await guards[guard]();
            if (!passed) return;
        }
        
        await load(url, target);
    });
    
    // Handle bz-post forms
    document.addEventListener('submit', async (e) => {
        const form = e.target.closest('[bz-post]');
        if (!form) return;
        
        e.preventDefault();
        
        const url = form.getAttribute('bz-post');
        const target = form.getAttribute('bz-target');
        
        // Validate if forms module available
        if (window.bunzForms) {
            const { valid, errors } = window.bunzForms.validate(form);
            if (!valid) {
                console.error('Form validation errors:', errors);
                // Could dispatch event for UI to handle
                return;
            }
        }
        
        const formData = new FormData(form);
        
        try {
            const res = await fetch(url, {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });
            
            const html = await res.text();
            const targetEl = document.querySelector(target || config.defaultTarget);
            if (targetEl) {
                targetEl.innerHTML = html;
                
                // Execute scripts
                if (window.bunzScripts) {
                    await window.bunzScripts.execute(html, targetEl);
                }
            }
            
            document.dispatchEvent(new CustomEvent('bz:submitted', { 
                detail: { url, target } 
            }));
        } catch (err) {
            console.error('BUNZ Post Error:', err);
        }
    });
    
    // Handle browser back/forward
    window.addEventListener('popstate', async (e) => {
        if (e.state && e.state.url) {
            await load(e.state.url, e.state.target, false);
        }
    });
    
    // Helper to get HTX file path (handles dynamic routes)
    // Pages are now in /htx/pages/ subdirectory
    function getHTXPath(pathname) {
        if (pathname === '/') return '/htx/pages/index.htx';
        
        // Handle dynamic routes: /meeting/123 -> /htx/pages/meeting.htx
        const segments = pathname.split('/').filter(Boolean);
        if (segments.length > 1) {
            return `/htx/pages/${segments[0]}.htx`;
        }
        
        return `/htx/pages${pathname}.htx`;
    }
    
    // Load initial page
    // Note: Scripts with defer run AFTER DOMContentLoaded fires
    // So we can't rely on DOMContentLoaded listener - check immediately
    function initPage() {
        const path = window.location.pathname;
        const appEl = document.querySelector(config.defaultTarget);
        
        console.log('üîç Checking for SSR...');
        console.log('üîç App element:', appEl);
        console.log('üîç data-prerendered attribute:', appEl?.getAttribute('data-prerendered'));
        console.log('üîç App innerHTML length:', appEl?.innerHTML?.length);
        
        // Check if content is already SSR'd (pre-rendered)
        if (appEl && appEl.getAttribute('data-prerendered') === 'true') {
            console.log('‚úÖ Page is SSR\'d, no fade-in animation');
            appEl.removeAttribute('data-prerendered');
            
            // Still execute scripts in pre-rendered content
            if (window.bunzScripts && appEl.innerHTML.includes('<script>')) {
                const html = appEl.innerHTML;
                window.bunzScripts.execute(html, appEl);
            }
            
            // Dispatch loaded event for SSR content
            document.dispatchEvent(new CustomEvent('bz:loaded', { 
                detail: { url: path, target: config.defaultTarget, ssr: true } 
            }));
            
            return;
        }
        
        // No SSR, load client-side
        console.log('‚ö° No SSR, loading client-side with animation');
        const htxFile = getHTXPath(path);
        fetch(htxFile, { method: 'HEAD' })
            .then(res => res.ok ? load(htxFile, config.defaultTarget, false) : null)
            .catch(() => load('/htx/pages/index.htx', config.defaultTarget, false));
    }
    
    // Call immediately if DOM ready, otherwise wait
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPage);
    } else {
        initPage();
    }
    
    // Export API
    window.bunz = { load, guards, config };
    
    console.log('‚úÖ BUNZ Routing initialized');
})();


