'use strict';class BunzTemplates{cache=new Map();async loadAtom(name){const cacheKey=`atom:${name}`;if(this.cache.has(cacheKey)){return this.cache.get(cacheKey);}try{const response=await fetch(`/htx/atoms/${name}.htx`);if(!response.ok){throw new Error(`Atom not found:${name}`);}const html=await response.text();const temp=document.createElement('div');temp.innerHTML=html;const walker=document.createTreeWalker(temp,NodeFilter.SHOW_COMMENT);const commentsToRemove=[];while(walker.nextNode()){commentsToRemove.push(walker.currentNode);}commentsToRemove.forEach(comment=>comment.remove());const cleanedTemplate=temp.innerHTML.trim();this.cache.set(cacheKey,cleanedTemplate);return cleanedTemplate;}catch(error){console.error(`Failed to load atom:${name}`,error);throw error;}}render(template,data={}){return template.replace(/{(\w+)}/g,(match,key)=>{const value=data[key];return value!==undefined ? value:'';});}async renderAtom(atomName,data={}){const template=await this.loadAtom(atomName);return this.render(template,data);}async createElement(atomName,data={}){const html=await this.renderAtom(atomName,data);const temp=document.createElement('div');temp.innerHTML=html;const element=temp.firstElementChild;if(!element){throw new Error(`Failed to create element from atom:${atomName}`);}return element;}async createElements(atomName,dataArray=[]){return Promise.all(dataArray.map(data=>this.createElement(atomName,data)));}async preload(atomNames=[]){await Promise.all(atomNames.map(name=>this.loadAtom(name)));console.log(`âœ… Preloaded ${atomNames.length}atom(s):`,atomNames.join(','));}clearCache(){this.cache.clear();console.log('ğŸ—‘ï¸ Template cache cleared');}}window.bunzTemplates=new BunzTemplates();console.log('âœ… BUNZ Templates initialized(atomic micro-templates)');